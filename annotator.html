<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Annotator Demo</title>
</head>
<body>
<h1>Annotator Demo</h1>

<h2>Instructions</h2>
<p><a href="https://github.com/RichCaloggero/annotator/">See README for instructions.</a></p>

<div class="annotator" role="region" aria-label="Annotator">
<div class="controls">
<div role="region" aria-label="Project">
<h2 id="projectName"></h2>
<label>Project: <input type="text" id="project"></label>

<button id="restore" accesskey="r">restore project</button>
<label>Load Project: <select id="projects"></select></label>
<button id="save" accesskey="s">Save Project</button>
<button id="delete" accesskey="d">Delete Project</button>
</div><div>
<label>Note: <input type="text" id="note" accesskey="n"></label>
<button id="addNote">Add Note</button>
</div><div>
<label>Enable Annotator <input type="checkbox" checked id="enableAnnotator" accesskey="a"></label>
<label>Enable Text Modification<input type="checkbox" id="enableTextModification" accesskey="e"></label>
</div>
</div><!-- controls -->
<hr>

<div class="container">
<ul id="annotations"></ul>

<div contenteditable="true" id="text" role="textbox" tabindex="0" aria-multiline="true" accesskey="t"
style="white-space: pre-wrap;">
</div><!-- .text -->
</div><!-- .container -->

<hr>
<div id="message" aria-live="polite"></div>
</div><!-- .annotator -->


<script>
"use strict";
const $ = document.querySelector.bind(document);
const $$ = document.querySelectorAll.bind(document);

const annotator = $(".annotator");
const text = $("#text");
const controls = $(".controls");
const enableAnnotator = $("#enableAnnotator");
const enableTextModification = $("#enableTextModification");
const save = $("#save");
const restore = $("#restore");
const annotations = $("#annotations");
const annotationMap = new WeakMap();
const projects = $("#projects");

/// variables
let start = null;
let project = {};
let annotation = {};

/// listen for events

$("#text").addEventListener("keydown", filterKeys);
$("#text").addEventListener("keyup", setAnnotationMode);

$("#annotations").addEventListener("click", e => annotation = loadAnnotation(annotationMap.get(e.target.closest(".annotation"), project.annotations)));

$("#addNote").addEventListener("click", () => {
addNote(annotation, $("#note").value)
displayAnnotation(annotation, annotationMap.get(annotation));
});

$("#projects").addEventListener("change", e => project = loadProject(findProject(e.target.value)));
$("#save").addEventListener("click", () => saveProject(project));

$("#enableAnnotator").addEventListener ("click", (e) => {
text.contentEditable = e.target.checked? "true" : "false";
if (!e.target.checked&& enableTextModification.checked) enableTextModification.checked = false;
compensateForNVDAAccessKeyBug (e.target);
});

$("#enableTextModification").addEventListener ("click", (e) => {
if (e.target.checked&& !enableAnnotator.checked) enableAnnotator.checked = true;
compensateForNVDAAccessKeyBug (e.target);
});


/// init

// create a project
project = createProject();

/// load default text
fetch("default.txt")
.then(response => response.text())
.then(_text => {
if (! text || !text.textContent) {
message ("No default text.");
$("#enableTextModification").checked = true;
text.textContent = project.text = "";
return;
} // if

text.textContent = _text;
project.text = text.textContent;
message("default text loaded.");
});

function compensateForNVDAAccessKeyBug (element, delay = 50) {
element.blur();
setTimeout(() => element.focus(), delay);
} // compensateForNVDAAccessKeyBug 

/// keyboard handlers

function filterKeys (e) {
if (enableTextModification.checked) return true;
const key = e.key;
switch (key) {
case "*": case "ArrowUp": case "ArrowDown": case "ArrowLeft": case "ArrowRight":
case "Home": case "End": case "Tab":
return true;

default: e.preventDefault();
return false;
} // switch
} // filterKeys

function setAnnotationMode (e) {
if (!text.isContentEditable) return false;
const key = e.key;
switch (key) {
case "*":
if (!start) {
start = copySelection(getSelection());
message ("Move to end of text to be annotated and press '*' again.");
} else {
processAnnotation(start, copySelection(getSelection()));
start = null;
} // if
return true;

default: return false;
} // switch



function processAnnotation (start, end) {
const s = getSelection();
const r = removeMarkers(start, end);

s.removeAllRanges();
s.addRange(r);

const newAnnotation = addAnnotation(createAnnotation(s.toString(), r), project.annotations);
if (newAnnotation) {
annotation = newAnnotation;
loadAnnotations(project.annotations);
displayAnnotation(annotation, document.createElement("li"));

} else {
message("Cannot create annotation.");
} // if

function removeMarkers (_start, _end) {
const start = _start.anchorNode;
const startOffset = _start.anchorOffset-1;
const end = _end.anchorNode;
const endOffset = _end.anchorOffset-1;
//message(`removeMarkers: ${startOffset}, ${start.textContent[startOffset]}, ${endOffset}, ${end.textContent[endOffset]}`);

const t2 = removeCharacter(end.textContent, endOffset);
end.textContent = t2;

const t1 = removeCharacter(start.textContent, startOffset);
start.textContent = t1;

const r = new Range();
r.setStart(start, startOffset);
r.setEnd(end, endOffset-1); // one less because of merker removal
return r;
} // removeMarkers
} // processAnnotation
} // setAnnotationMode

/// handling selections and ranges

function removeCharacter (s, offset) {
//console.log ("removing: ", offset, s);
if (offset === 0) s = s.slice(1);
else if (offset === s.length-1) s = s.slice(0, -1);
else s = s.slice(0, offset) + s.slice(offset+1);
return s;
} // removeCharacter

/// annotation list

function addAnnotation (annotation, list) {
list.push(annotation);
return annotation;
}// addAnnotation

function removeAnnotation (annotation, list) {
return list.filter(a => a !== annotation);
} // removeAnnotation

function createAnnotation (title, range) {
return {
title: title,
range: copyRange(range),
notes: []
}; // annotation
} // createAnnotation


function addNote (annotation, text) {
annotation.notes.push(text);
return text;
} // addNote

function createAnnotationListItem (annotation, element) {
if (! element) return null;
element.innerHTML = "";
element.classList.add("annotation");
element.innerHTML = `<h3 class="title"><button class="display">${annotation.title}</button></h3>
<ul class="notes">
${annotation.notes.map(note => `<li class="note">${note}</li>`).join("\n")}
</ul>`;

annotationMap.set(element, annotation);
annotationMap.set(annotation, element);
return element;
} // displayAnnotation

function displayAnnotation (annotation) {
const r = annotation.range;
const range = new Range();
range.setStart(r.startContainer, r.startOffset);
range.setEnd(r.endContainer, r.endOffset);
const s = getSelection();
s.removeAllRanges();
s.addRange(range);
annotator.focus();
return annotation;
} // displayAnnotation

/// projects

function createProject (name) {
return {
name: name,
annotations: [],
};
} // createProject

function findProject (name) {
return localStorage[name] || null;
} // findProject

function saveProject (p) {
updateProject(p);

try {
if (! p.name && !confirm("Project has no name; abort project?")) return;

const json = JSON.stringify(p);
localStorage[p.name] = json;
} catch (e) {
message(e);
console.log(e);
} // catch

return p;
} // saveProject

function restoreProject (name) {
try {
let s = localStorage;
return JSON.parse(localStorage[name]);
} catch (e) {
message(e);
console.log(e);
} // catch

return null;
} // restoreProject

function loadProject (p) {
if (! p) return null;

saveProject(p);
loadAnnotations(p.annotations);
return p;
} // loadProject

function loadAnnotations (list) {
annotations.innerHTML = "";
list.forEach(annotation => {
annotations.appendChild(
createAnnotationListItem (annotation, document.createElement("li")) // loadAnnotation
); // appendChild
}); // forEach
return annotations;
} // loadAnnotations

function updateProject (project) {
project.name = $("project").value;
project.text = text.textContent;
project.annotations = annotations;

} // updateProject

/// utilities

function copySelection (selection) {
const copy = {
anchorNode: selection.anchorNode,
anchorOffset: selection.anchorOffset,
focusNode: selection.focusNode,
focusOffset: selection.focusOffset
};
//console.log ("copy: ", copy);
return copy;
} // copySelection

function copyRange (r) {
const copy = {
startContainer: r.startContainer,
startOffset: r.startOffset,
endContainer: r.endContainer,
endOffset: r.endOffset,
};
//console.log ("copy: ", copy);
return copy;
} // copyRange

function probeEvent (type, element = document.body) {
element.addEventListener(e => message(
`${element} just heard event ${e.type}, target ${e.target.toString()}`
)); // listener
} // probeEvent

function message (text) {
$("#message").textContent = text;
} // message

</script>


</body>
</html>
